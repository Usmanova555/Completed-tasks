Python 2 пара
****************************
говорим ещё о типах данных, помимо примитивов
else работает одинаково как для фора, так и для вайла
range (5) - от 0 до 4
break выполнился, после него в else не попадём
а если continue, то в else попадём.

pass - не делай ничего, заглушка
надо обработать случай, но ничего делать не надо (перехватили исключение, но ничего с ним не делаем)
при этом не сломать код

СТРОКИ  - неизменяемый упорядоченный тип
синтаксис - неважно какие кавычко, при этом есть тройные кавычки - многострочные вези

Операции над строками
+ - это для строки со строкой
сложить строку с числом нельзя - это не конкатенация, это сложение
зато есть умножение строки на число - строка повторится столько раз, какое число...
можно обратиться к индексу, как в массивах
-1 индекс - последний индекс в массиве или в строке, с минисами можно работать с конца строки

slicing
попытка вырезать какие-либо штуки из строки или массива

форматирование
прикольная штука

функция format - строки
.format(порядковый номер аргумента / название) строки - не оч для больших строк
f - string
это код, который исполняется! как питон код

В ПИТОНЕ НЕТ МАССИВОВ!
вместо них списки - не ставят ограничения на однотипность данных
в кв скобках набор, который нужен или вызываем ...

Dist - словари, с ними можно рабоать точно так же, как и с массивами
словари в питоне тоже изменяемые и упорядоченные, ключи при этом должны быть тоже изм
в питоне всего три неизменяемых типа - это числа, строки и картежиБ больше ничегьо не может быть ключом

словари записываются : ключ, двоеточие, значение и т.д., во много строчек читается по-приятнее

в словарь множно вложить любую другую структуру - можно словарь, можно кортеж и тд

Tuple - кортеж - единственная неизменяемая коллекция - поменять значение по какому-то индексу нельзя

Set - неупорядоченный тип, набор уникальных значений - чаще всег исп для подсчёта уник знач в списке и тд, взяли список что-то сделали, а потом надо выбрать оттуда только уникальные.
Засунули в сет и получили только уникальные.

bool - True или False
None - привычный null


3 пара
*****************************
декотаторы - для подсчёта времени выполнения функции
import time
def _print(val: int) -> None:
    start = time()
    print(f"My awesome print {val})

_print(1)
_print('1')

def _print(val: int) -> None:
    print(f"My awesome print {val}")

   _print(1)
   _print('1')

# штука которая так делает называется mypy

# парадигмы прогр - общий подход для написания вот этого всего - их где-то 6. 
импер прогр - ассемблер (одна процедура за другой)
логич прогр - лист

вообще всё в питоне объект!
но при этом можно писать в вйнк стиле и никто не запретит.
Декораторы
что сделать? можно посчитать время выполн функции - 9:30
считает в миллисекундах
не оч прикольно, поэтому
16:30 какая-то жесть со временем, для посчёта времени
передаём функции аргументы - звёздочки магические
распаковка и запаковка
а в случае с ф - позволяет сразу несколько аргументов
31:40 - как классно выглядит декоратор

декоратор, который считает кол-во вызовов функции
@ - вот это декоратор

конструкция, которая проверяет есть ли ключ в словаре
функция - это объект, который можно вызвать
декоратором может быть всё, что можно вызвать
класс тоже может быть декоратором

Итератор - тоже функция, возвращает итерированный объект (по которому можно пройтись один за одним, забирая оттуда значения)
создаётся объект этого класса и методом нехт вызывается каждое значение
для того, что бы создать итератор достаточно методов инит и нехт
для того чтобы сделать метод итерированным в цикле фор нужно ещё переопределить метод итер. Этого достаточно, чтобы называть всё итератором

сосед итератора - это генератор (синстаксический сахар над итераторами)
генератор каждый раз просчитывает новое значение

Comprehensions - однострочная запись списков / словарей
1:23:15 


4 практика
*****************************

()-ы в [] - таплы
В круглых скобках класса - родители
С отступом в 4 пробела тело класса
Интерфейсов нет
Абстр методов тоже
__init__ - конструктор
self в питоне это как this в си шарпе

Обработка исключений:
Блок else вместо finally
Чтобы перезватить иксл - StopIteration
Чтобы поймать - сохранить в переменную
Yield- исп с генераторами (ленивые итераторы, отдают что-то по запросу).
Вызываем генератор и получ объект генератора
На генераторах построена асинхронность в питоне

Команда yield может принимать какие-то значения, а может возвращать и записывать в какие-то переменные

Модуль inspect - рефлексия в питоне это хорошо
Рассказывает про всякие объекты, пуьи и тд
Метод getgsneratorstate

Можно вызывать генератор внутри генератора. Начало того
Ветка отдаёт на обработку кусок
Асинхронное программирование.

from test import *
g = generator(subgen())

В других языках аналог yield from это awaid

Генераторы можно писать в одну строку

5 практика
****************************

род-е классы в круглых скобках
методы - self это указатель (как this), то есть он не меняется - метод объекта

Рефлексия:
__dict__: словарь
class SomeClass(object):
    attr1 = 42
    attr2 = "Some string"
    
    def method1(self, x):
        pass
print(SomeClass.__dict__)
что он делает? возвращает атрибуты и методы

объект возвращается просто так
obj = SomeClass()
obj.method1(6)
obj.attr1

Конструктор - специальный зарезервированный метод с именем __init__ (self как указатель, переменные)
ну конструктор это конструктор, всё как обычно

Статические методы опр через декоратор @staticmethod
Их можно воспринимать как методы, которые “не знают, к какому классу относятся”

поскольку питон динамический язык, можно динамически изменять классы, объекты
добавлять методы, определять методы на лету 
def squareMethod(self, x):
    return x*x
SomeClass.square = squareMethod
obj = SomeClass()
print(obj.square(5)) 
# self обязательно нужен, потому что работаем на объекте и выводим через класс, 
потому что статический класс

у класса есть методы, которые его конструируют (это объект),
__new__ то есть 
(cls) - cсылка на класс
метод __new__: статический метод, вызывается когда создается экземпляр класса. 
В общем, сначала он, потом __init__

super() - это функция, которая обращается к классу, от которого наследуется текущий

синглтон - класс у которого мб только 1 объект (экземпляр)
синглтон можно реализовать через конструктор
c бд используется
чего бы мы не переопределяли там, это остаётся одним объектом

def __new__(cls, *args, **kwargs): - так можно создать чего-то там

деструктор - есть, но исп очень редко (__del__) 

объект как функция - методы, которые можно переопределять и делать класс похожим
на что-то другое __call__ вызыв. тогда, когда вызывается класс как функция
тут ещё забыли в принт это всё вложить
то есть как только опр метод call класс сразу становится коллабел и можно 
вызвать класс как функцию

из классов можно сделать коллекцию, определить метод __len__, который возвращает длину
практически все методы, которые имеют __//__ можно вызвать как обычные функции
len(collect)
4 метода в классе collections

__init__ - это конструктор 

метод __str__ для печати, который определяет что произойдёт 

метод __repr__ вызывает репрезентацию объкта

инкапсуляция в питоне  
все приватные методы и атрибуты начинаются с нижнего подчёркивания
они всё ещё доступны из вне
соглашение разработчиков между собой
__ - это защизённый атрибут, обращением к нему достать его нельзя,
но чё-нить придумать можно

property - это сеттеры и геттеры

если нужно использовать сеттер вместо декоратора, то декоратор называется как 
этот метод.setter, потом функция и чёто там

__getattribute__ - метод, когда мы пытаемся достать значение любого атрибута класса
__getattr__ вызывается тогда, когда гетаттрибьют не сработал, то есть для того, 
что не вывелось

порядок доступа - 6 пунктов, по которым проходится интерпритатор когда пытается найти 
атрибут 
любят давать на собеседовании

в питоне есть множественное наследование, а интерфейсов нет вообще
diamond problem - чёто там наследование от одного к чему-то
когда идёт от детей сначала, потом считаются родители

полиморфизм - переопределение методов

метаклассы - класс это объект, значит его кто-то создаёт - instance методы какого-то класса
классы можно сделать динамически
редко исп:
функция type - это метакласс, внутри название класса, перечисление всех родителей в виде кортежа, 
если родителей нет, то кортеж пустой, внимание на запятую; словарь с атрибутами класса - 
метод 'echo_bar'
через type можно при запуске создать свой класс вот так 
hasattr проверяет есть ли атрибут
ну то есть сначала создаются всякие там методы, атрибуты, потом они исп в метаклассе
type
вот так легко можно создать классы

ну ещё можно создать свой метакласс. переопределив его от type