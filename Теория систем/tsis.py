import Cryptodome

from Cryptodome.Signature import PKCS1_v1_5  # pip install pycryptodomex
from Cryptodome.Hash import SHA256
from Cryptodome.PublicKey import RSA
from base64 import decodebytes, encodebytes

import json
import requests
import urllib.parse

import numpy as np
import pandas as pd

import tensorflow as tf

from tensorflow import keras
from tensorflow.keras import layers

from tensorflow.python.keras.models import Sequential
from tensorflow.python.keras.layers import Dense

if __name__ == '__main__':
    # -*- coding: utf-8 -*-
    """task4.1.ipynb

    Automatically generated by Colaboratory.

    Original file is located at
        https://colab.research.google.com/drive/1JsZl4pUt9ixf7nTs8hVi1STOI8qMENci

    ## Импорты
    """

    import pandas as pd
    import datetime
    import numpy as np

    import math

    """## Чтение данных"""

    filePath = "./ddd.csv"
    df = pd.read_csv(filePath)

    df.head()

    df['date'] = pd.to_datetime(df.date)
    df['count'] = 1

    print(df.shape[0])
    print(df.head())

    q = df['date']
    q.iloc[-1] < datetime.datetime(2021, 9, 1)

    print(df.tail())

    # убираем последние два месяца (лишние данные - после августа 2021 года)
    df = df[df['date'] < datetime.datetime(2021, 9, 1)]

    print(df.tail())

    """# Оценка интенсивности прихода заявок в систему.

    ## Получаем данные за июль 2020
    """

    dfMy = df.copy()
    dfMy = dfMy[dfMy.date >= datetime.datetime(2020, 7, 1)]
    dfMy = dfMy[dfMy.date < datetime.datetime(2020, 8, 1)]

    print(dfMy.size)
    print(dfMy.head())

    """## Выборочная дисперсия"""


    def getVariance(arr, koef=1):
        mean = np.mean(arr) * koef
        v = 0
        for x in arr:
            v += (x * koef - mean) * (x * koef - mean)
        return v / len(arr)


    """## 1) Постройте статистический ряд количества заявок в течение часа за три дня"""

    byHours = dfMy.groupby(pd.Grouper(key="date", freq="h")).count()['count'][0:72]
    byHours

    mean1 = byHours.mean()
    print(f'Среднее = {mean1}')
    var1 = getVariance(byHours)
    print(f'Дисперсия = {var1}')

    """## 2) Cтатистический ряд количества заявок в течение дня за месяц"""

    byDays = dfMy.groupby(pd.Grouper(key="date", freq="d")).count()['count']
    byDays

    mean2 = byDays.mean() / 24
    print(f'Среднее = {mean2}')
    var2 = getVariance(byDays, 1 / 24)
    print(f'Дисперсия = {var2}')

    """## 3.1) Воспользуйтесь данными двух месяцев, соседних Вашему варианту. Постройте статистический ряд количества заявок в течение понедельника за три месяца"""

    df3Months = df.copy()
    df3Months = df3Months[df3Months.date >= datetime.datetime(2020, 6, 1)]
    df3Months = df3Months[df3Months.date < datetime.datetime(2020, 9, 1)]
    df3Months['weekday'] = df3Months['date'].dt.dayofweek

    print(df3Months.size)
    print(df3Months.head())

    onlyMondays = df3Months[df3Months.weekday == 0]
    byMondays = onlyMondays.groupby(pd.Grouper(key="date", freq="w")).count()['count']
    byMondays

    mean3 = byMondays.mean() / 24
    print(f'Среднее = {mean3}')
    var3 = getVariance(byMondays, 1 / 24)
    print(f'Дисперсия = {var3}')

    """## 3.2) Воспользуйтесь данными двух месяцев, соседних Вашему варианту. Постройте статистический ряд количества заявок в течение воскресенья за три месяца"""

    onlySundays = df3Months[df3Months.weekday == 6]
    bySundays = onlySundays.groupby(pd.Grouper(key="date", freq="w")).count()['count']
    bySundays

    mean4 = bySundays.mean() / 24
    print(f'Среднее = {mean4}')
    var4 = getVariance(bySundays, 1 / 24)
    print(f'Дисперсия = {var4}')

    """## 4) Воспользуйтесь данными двух месяцев, соседних Вашему варианту. Постройте статистический ряд количества заявок в течение недели за три месяца"""

    byWeeks = df3Months.groupby(pd.Grouper(key="date", freq="w")).count()['count']
    byWeeks

    mean5 = byWeeks.mean() / 7 / 24
    print(f'Среднее = {mean5}')
    var5 = getVariance(byWeeks, 1 / 7 / 24)
    print(f'Дисперсия = {var5}')

    """## 5) Воспользуйтесь всем датасетом. Постройте статистический ряд количества заявок в течение месяца за весь период наблюдения"""

    byMonths = df.groupby(pd.Grouper(key="date", freq="m")).count()['count']
    byMonths

    mean6 = byMonths.mean() / 30 / 24
    print(f'Среднее = {mean6}')
    var6 = getVariance(byMonths, 1 / 30 / 24)
    print(f'Дисперсия = {var6}')

    """## 6) Выберите среднюю интенсивность, соответствующую минимальной дисперсии"""

    vars = [var1, var2, var3, var4, var5, var6]
    means = [mean1, mean2, mean3, mean4, mean5, mean6]

    pairs = np.array(list(zip(vars, means)))
    print(pairs)

    minVar, minMean = sorted(pairs, key=lambda x: x[0])[0]
    print(f'Минимальная дисперсия: {minVar} со средним {minMean}')

    """# Имеется информация о начале времени записи регистрации в базу данных. Операция  записи длится в среднем 2,3 с. В системе задействовано 8 параллельных потоков.  Если  в момент прихода новой заявки все потоки заняты, то заявка становится в очередь. Таймаут ожидания обработки ответа составляет 30 с. По истечению времени таймаута необработанная заявка теряется. Аренда одного ядра (2 потока) 2400 руб. в месяц. Штраф за потерю заявки равен x руб. 
    # 1.	Определите основные параметры системы. Используя статистические данные, рассчитайте среднюю интенсивность потока заявок. Найдите процент необработанных заявок. Каково среднее время, которое заявка находится в очереди? Какова средняя сумма от штрафов за месяц? Определите значение х, при котором арендовать более 20 ядер не выгодно.
    # 2.	Увеличьте в три раза значение x, полученное в предыдущем пункте, и рассчитайте для него оптимальное количество используемых ядер


    """

    from decimal import *

    n = 8
    print(f'Количество потоков: {n}')
    t = 30 / 60 / 60
    print(f't: {t}')

    fst = df['date'].iloc[0]
    lst = df['date'].iloc[-1]
    # seconds = (lst - fst).total_seconds()
    # requestInSec = seconds / df.shape[0]
    # lambd = 1 / requestInSec # заявок в секунду - интенсивность
    lambd = minMean
    print(f'Средняя интенсивность заявок: {lambd} заявок в час')

    nu = 1 / 2.3 * 60 * 60  # пропускная способность - заявок в час
    print(f'Пропускная способность: {nu} заявок в час')

    ro = lambd / nu
    print(f'Ро: {ro}')
    a = n / ro
    print(f'a: {a}')
    b = lambd * t
    print(f'b: {b}')
    c = math.exp(b * (1 - a))
    print(f'c: {c}')
    B = ((c - 1) / (1 - a))
    print(f'B: {B}')

    p0 = 0
    for k in range(0, n + 1):
        p0 += ro ** k / math.factorial(k)
    p0 += ro ** n * B / math.factorial(n)
    p0 **= -1
    print(f'p0: {p0}')

    pOtk = Decimal(ro ** n) * Decimal(c) * Decimal(p0) / math.factorial(n)
    print(f'pOtk: {pOtk}')
    Q = 1 - pOtk
    print(f'Q: {Q}')
    lambdaEff = Decimal(lambd) * Q
    print(f'lambdaEff: {lambdaEff}')
    lambdaOtk = Decimal(lambd) * pOtk
    print(f'lambdaOtk: {lambdaOtk}')

    D = (a - c * (a + b * (a - 1))) / (b * (a - 1) ** 2)
    print(f'D: {D}')

    Wo = t * (ro ** n / math.factorial(n)) * D * p0
    print(f'Wo: {Wo}')

    print('#################################################')

    print(f'Процент необработанных заявок: {pOtk * Decimal(100)} %')
    print(f'Среднее время заявки в очереди: {Wo} часов')
    months = (lst.month + lst.year * 12) - (fst.month + fst.year * 12) + 1
    shtrafsInMonth = pOtk * df.shape[0] / months
    print(f'Среднее число штрафов в месяц: {shtrafsInMonth} штук')

    """## Считаем все для 20 и 21 ядер"""

    from decimal import *

    n = 40
    print(f'Количество потоков: {n}')
    t = 30 / 60 / 60
    print(f't: {t}')

    fst = df['date'].iloc[0]
    lst = df['date'].iloc[-1]
    # seconds = (lst - fst).total_seconds()
    # requestInSec = seconds / df.shape[0]
    # lambd = 1 / requestInSec # заявок в секунду - интенсивность
    lambd = minMean
    print(f'Средняя интенсивность заявок: {lambd} заявок в час')

    nu = 1 / 2.3 * 60 * 60  # пропускная способность - заявок в час
    print(f'Пропускная способность: {nu} заявок в час')

    ro = lambd / nu
    print(f'Ро: {ro}')
    a = n / ro
    print(f'a: {a}')
    b = lambd * t
    print(f'b: {b}')
    c = math.exp(b * (1 - a))
    print(f'c: {c}')
    B = ((c - 1) / (1 - a))
    print(f'B: {B}')

    p0 = 0
    for k in range(0, n + 1):
        p0 += ro ** k / math.factorial(k)
    p0 += ro ** n * B / math.factorial(n)
    p0 **= -1
    print(f'p0: {p0}')

    pOtk = Decimal(ro ** n) * Decimal(c) * Decimal(p0) / math.factorial(n)
    print(f'pOtk: {pOtk}')
    Q = 1 - pOtk
    print(f'Q: {Q}')
    lambdaEff = Decimal(lambd) * Q
    print(f'lambdaEff: {lambdaEff}')
    lambdaOtk = Decimal(lambd) * pOtk
    print(f'lambdaOtk: {lambdaOtk}')

    D = (a - c * (a + b * (a - 1))) / (b * (a - 1) ** 2)
    print(f'D: {D}')

    Wo = t * (ro ** n / math.factorial(n)) * D * p0
    print(f'Wo: {Wo}')

    print('#################################################')

    print(f'Процент необработанных заявок: {pOtk * Decimal(100)} %')
    print(f'Среднее время заявки в очереди: {Wo} часов')
    months = (lst.month + lst.year * 12) - (fst.month + fst.year * 12) + 1
    shtrafsInMonth20 = pOtk * df.shape[0] / months
    print(f'Среднее число штрафов в месяц: {shtrafsInMonth20} штук')

    from decimal import *

    n = 42
    print(f'Количество потоков: {n}')
    t = 30 / 60 / 60
    print(f't: {t}')

    fst = df['date'].iloc[0]
    lst = df['date'].iloc[-1]
    # seconds = (lst - fst).total_seconds()
    # requestInSec = seconds / df.shape[0]
    # lambd = 1 / requestInSec # заявок в секунду - интенсивность
    lambd = minMean
    print(f'Средняя интенсивность заявок: {lambd} заявок в час')

    nu = 1 / 2.3 * 60 * 60  # пропускная способность - заявок в час
    print(f'Пропускная способность: {nu} заявок в час')

    ro = lambd / nu
    print(f'Ро: {ro}')
    a = n / ro
    print(f'a: {a}')
    b = lambd * t
    print(f'b: {b}')
    c = math.exp(b * (1 - a))
    print(f'c: {c}')
    B = ((c - 1) / (1 - a))
    print(f'B: {B}')

    p0 = 0
    for k in range(0, n + 1):
        p0 += ro ** k / math.factorial(k)
    p0 += ro ** n * B / math.factorial(n)
    p0 **= -1
    print(f'p0: {p0}')

    pOtk = Decimal(ro ** n) * Decimal(c) * Decimal(p0) / math.factorial(n)
    print(f'pOtk: {pOtk}')
    Q = 1 - pOtk
    print(f'Q: {Q}')
    lambdaEff = Decimal(lambd) * Q
    print(f'lambdaEff: {lambdaEff}')
    lambdaOtk = Decimal(lambd) * pOtk
    print(f'lambdaOtk: {lambdaOtk}')

    D = (a - c * (a + b * (a - 1))) / (b * (a - 1) ** 2)
    print(f'D: {D}')

    Wo = t * (ro ** n / math.factorial(n)) * D * p0
    print(f'Wo: {Wo}')

    print('#################################################')

    print(f'Процент необработанных заявок: {pOtk * Decimal(100)} %')
    print(f'Среднее время заявки в очереди: {Wo} часов')
    months = (lst.month + lst.year * 12) - (fst.month + fst.year * 12) + 1
    shtrafsInMonth21 = pOtk * df.shape[0] / months
    print(f'Среднее число штрафов в месяц: {shtrafsInMonth21} штук')

    x = 2400 / (shtrafsInMonth20 - shtrafsInMonth21)
    print(f'x: {x}')
    x3 = x * 3
    print(f'x3: {x3}')

    mins = []
    for n2 in range(40, -1, -1):
        n = n2 * 2
        t = 30 / 60 / 60

        fst = df['date'].iloc[0]
        lst = df['date'].iloc[-1]
        # seconds = (lst - fst).total_seconds()
        # requestInSec = seconds / df.shape[0]
        # lambd = 1 / requestInSec # заявок в секунду - интенсивность
        lambd = minMean

        nu = 1 / 2.3 * 60 * 60  # пропускная способность - заявок в час

        ro = lambd / nu
        a = n / ro
        b = lambd * t
        c = math.exp(b * (1 - a))
        B = ((c - 1) / (1 - a))

        p0 = 0
        for k in range(0, n + 1):
            p0 += ro ** k / math.factorial(k)
        p0 += ro ** n * B / math.factorial(n)
        p0 **= -1

        pOtk = Decimal(ro ** n) * Decimal(c) * Decimal(p0) / math.factorial(n)
        Q = 1 - pOtk
        lambdaEff = Decimal(lambd) * Q
        lambdaOtk = Decimal(lambd) * pOtk

        D = (a - c * (a + b * (a - 1))) / (b * (a - 1) ** 2)

        Wo = t * (ro ** n / math.factorial(n)) * D * p0

        months = (lst.month + lst.year * 12) - (fst.month + fst.year * 12) + 1
        shtrafsInMonth = pOtk * df.shape[0] / months
        price = 2400 * n2
        print(
            f'{n2} ядер: штрафов = {shtrafsInMonth}, сумма штрафа = {shtrafsInMonth * x3}, цена ядер = {price}, штрафы + ядра = {shtrafsInMonth * x3 + price}')
        mins.append(shtrafsInMonth * x3 + price)

    pairs = np.array(list(zip(mins, range(40, -1, -1))))

    minCost, minN = sorted(pairs, key=lambda x: x[0])[0]
    print(f'{minCost} при {minN} ядрах')